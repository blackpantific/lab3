kernel void sum(global const int* a, global const int*b, global int *c){

		uint i = get_global_id(0);

		printf("\ni = %i", i);
		c[i] = a[i] + b[i];
		printf("\na[%i] = %i  b[%i] = %i c[%i] = %i", i, a[i], i, b[i], i, c[i]);
}

kernel void matrix_global(global const float* a, global const float* b, global float *c, int widthA, int widthB){

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата


		printf("\nvalue1 = %i", widthA);

		float value = 0.0;

		for(int i = 0; i < widthA; i++){
			
			value += a[global_y * widthA + i] * b[global_x + i * widthB];
		
		}

		c[global_x + global_y * widthB] = value;
		//printf("\nvalue = %f", value);

}

kernel void matrix_local(global const float* a, global const float* b, global float* c, int widthA, int widthB){

		int local_x = get_local_id(0);
		int local_y = get_local_id(1);

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата


		local float locMatrA[LOCALWS][LOCALWS];//заменить 2 на ширину(она же высота) сабматрицы лок группы, т.е. A
		local float locMatrB[LOCALWS][LOCALWS];//заменить 2 на ширину(она же высота) сабматрицы лок группы, т.е. B
		local float locMatrC[LOCALWS][LOCALWS];

		//printf("\nlocal_x = %i, local_y = %i, global_x = %i, global_y = %i",
		//local_x,
		//local_y,
		//global_x,
		//global_y);

		for(int i = 0; i < NUM_OF_SUBMATRIX; i++){//2 в данном случае это количество сабплиток умещающихся по ширине всей глобал работы, т.е 4 надо реплейснуть потом на константу. количество сабплиток это ширина итоговой матрицы делить на ширину лок. группы


			locMatrA[local_y][local_x] = a[global_y * widthA + local_x + i*LOCALWS];//2 тоже поменять на ширину сабматрицы
			int shiftInY = 0;
			if(global_y + 1 <= LOCALWS){
			
				locMatrB[local_y][local_x] = b[global_x + LOCALWS * i * widthB + widthB * global_y];//2 поменять на кол-во строк сабматрицы
			}else{
			
				///summary: это смещение от 0 в пределах сабматрицы для того чтобы "прыгать" через определенное количество элементов
				//в других сабматрицах. Ищется только для матрицы B
				
				shiftInY = (global_y) % LOCALWS;
				

				locMatrB[local_y][local_x] = b[global_x + LOCALWS * i * widthB + widthB * shiftInY];//2 поменять на кол-во строк сабматрицы
				//if((global_y == 4 || global_y == 5) && (global_x == 0 || global_x == 1)){
				
					//printf("\nlocMatrB[%d][%d] = b[%d + LOCALWS * %d * %d + %d * %d] = %f", local_y, local_x, global_x, 
					//i, widthB, widthB, shiftInY, b[global_x + LOCALWS * i * widthB + widthB * shiftInY]);
				//}
			}


			barrier(CLK_LOCAL_MEM_FENCE);

			float value = 0.0;
			float tempValue = 0.0;


			for(int k = 0; k < LOCALWS; k++){
			
				value += locMatrA[local_y][k] * locMatrB[k][local_x];
	
			}

			barrier(CLK_LOCAL_MEM_FENCE);

			c[global_x + global_y * widthB] += value;











			//if((global_y == 0 || global_y == 1) && (global_x == 2 || global_x == 3)){
				
				//printf("\nlocMatrB[%i][%i] = %f, i=%i, global_x = %i, global_y = %i, %f",
				//local_y, 
				//local_x, 
				//locMatrB[local_y][local_x],
				//i,
				//global_x,
				//global_y,
				//b[global_x + 2 * i * widthB + widthB * global_y]);
				
			//}

			//if((global_y == 2 || global_y == 3) && (global_x == 2 || global_x == 3)){
			
				//printf("\nlocMatrA[%i][%i] = %f, i=%i, global_x = %i, global_y = %i, %f",
				//local_y, 
				//local_x, 
				//locMatrA[local_y][local_x],
				//i,
				//global_x,
				//global_y,
				//a[global_y * widthA + local_x + i*2]);
			//}

		}
}


kernel void matrix_local_custom(global const float* a, global const float* b, global float* c, int widthA, int widthB){

		int local_x = get_local_id(0);
		int local_y = get_local_id(1);

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата


		local float locMatrA[LOCALWS][LOCALWS];//заменить 2 на ширину(она же высота) сабматрицы лок группы, т.е. A
		local float locMatrB[LOCALWS][LOCALWS];//заменить 2 на ширину(она же высота) сабматрицы лок группы, т.е. B

		//printf("\nlocal_x = %i, local_y = %i, global_x = %i, global_y = %i",
		//local_x,
		//local_y,
		//global_x,
		//global_y);

		for(int i = 0; i < NUM_OF_SUBMATRIX; i++){
		

			for(int iterA = 0; iterA < 2; iterA++){
			//iterA это итератор переноса 2, 4, 8 или 16 элементов одним тредом,
			//чтобы руками не писать запись в каждый элемент от 0-8 в массиве используем цикл

				locMatrA[local_y][local_x] = a[global_y * widthA + local_x + i*LOCALWS];
				locMatrA[local_y][local_x + 1 + iterA] = a[global_y * widthA + local_x + 1 + iterA + i*LOCALWS];//поменять 1 на iter в цикле
			}
			
			//if(i == 0){
			//printf("\nlocalMatrA = %f, localMatrA1 = %f",
			//a[global_y * widthA + local_x + i*LOCALWS],
			//a[global_y * widthA + local_x + 1 + i*LOCALWS]);
			//}

			int shiftInY = 0;
			if(global_y + 1 <= LOCALWS){
			
				locMatrB[local_y][local_x] = b[global_x * 2 + LOCALWS * i * widthB + widthB * global_y];
				locMatrB[local_y][local_x + 1] = b[global_x * 2 + LOCALWS * i * widthB + 1 + widthB * global_y];
			}else{
			
				///summary: это смещение от 0 в пределах сабматрицы для того чтобы "прыгать" через определенное количество элементов
				//в других сабматрицах. Ищется только для матрицы B
				
				shiftInY = (global_y) % LOCALWS;
				

				locMatrB[local_y][local_x] = b[global_x * 2 + LOCALWS * i * widthB + widthB * shiftInY];
				locMatrB[local_y][local_x + 1] = b[global_x * 2 + LOCALWS * i * widthB + 1 + widthB * shiftInY];
			}

			///ПЕРЕНОСИТ ПРАВИЛЬНО ПРИ global_y + 1 <= LOCALWS

			//if((global_y == 0 || global_y == 1) && i == 0){
				//printf("\nlocalMatrB = %f, localMatrB1 = %f",
				//locMatrB[local_y][local_x],
				//locMatrB[local_y][local_x + 1]
				//);
			//}
			
			///ПЕРЕНОСИТ ПРАВИЛЬНО ПРИ global_y + 1 > LOCALWS

			if((global_y == 2 || global_y == 3) && i == 0){
				printf("\nlocalMatrB = %f, localMatrB1 = %f",
				locMatrB[local_y][local_x],
				locMatrB[local_y][local_x + 1]
				);
			}



			barrier(CLK_LOCAL_MEM_FENCE);
		
		
		
		}

}
