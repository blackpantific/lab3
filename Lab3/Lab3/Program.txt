kernel void sum(global const int* a, global const int*b, global int *c){

		uint i = get_global_id(0);

		printf("\ni = %i", i);
		c[i] = a[i] + b[i];
		printf("\na[%i] = %i  b[%i] = %i c[%i] = %i", i, a[i], i, b[i], i, c[i]);
}

kernel void matrix_global(global const float* a, global const float* b, global float *c, int widthA, int widthB, int threadCalcUnits){

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата

		float value = 0.0;

		for(int i = 0; i < widthA; i++){
			
			value += a[global_y * widthA + i] * b[global_x + i * widthB];
		
		}

		c[global_x + global_y * widthB] = value;

}

kernel void matrix_local(global const float* a, global const float* b, global float* c, int widthA, int widthB, int threadCalcUnits){

		int local_x = get_local_id(0);
		int local_y = get_local_id(1);

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата


		local float locMatrA[LOCALWS][LOCALWS];
		local float locMatrB[LOCALWS][LOCALWS];
		local float locMatrC[LOCALWS][LOCALWS];

		for(int i = 0; i < NUM_OF_SUBMATRIX; i++){


			locMatrA[local_y][local_x] = a[global_y * widthA + local_x + i*LOCALWS];
			int shiftInY = 0;
			if(global_y + 1 <= LOCALWS){
			
				locMatrB[local_y][local_x] = b[global_x + LOCALWS * i * widthB + widthB * global_y];
			}else{

				shiftInY = (global_y) % LOCALWS;
				

				locMatrB[local_y][local_x] = b[global_x + LOCALWS * i * widthB + widthB * shiftInY];

			}


			barrier(CLK_LOCAL_MEM_FENCE);

			float value = 0.0;


			for(int k = 0; k < LOCALWS; k++){
			
				value += locMatrA[local_y][k] * locMatrB[k][local_x];
	
			}

			barrier(CLK_LOCAL_MEM_FENCE);

			c[global_x + global_y * widthB] += value;
		}
}


kernel void matrix_local_custom(global const float* a, global const float* b, global float* c, 
									int widthA, int widthB, int threadCalcUnits){

		int local_x = get_local_id(0);
		int local_y = get_local_id(1);

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата


		local float locMatrA[LOCALWS][LOCALWS];
		local float locMatrB[LOCALWS][LOCALWS];

		float values[THREAD_CALC_UNITS];


		for(int i = 0; i < NUM_OF_SUBMATRIX; i++){
		
			for(int numWorkIter = 0; numWorkIter < threadCalcUnits;  numWorkIter++){

				locMatrA[local_y][local_x * threadCalcUnits + numWorkIter] 
					= a[global_y * widthA + local_x * threadCalcUnits + numWorkIter + i*LOCALWS];
			}

			int shiftInY = 0;
			if(global_y + 1 <= LOCALWS){
			
				for(int numWorkIter = 0; numWorkIter < threadCalcUnits;  numWorkIter++){
					
					locMatrB[local_y][local_x * threadCalcUnits + numWorkIter] 
						= b[global_x * threadCalcUnits + LOCALWS * i * widthB + numWorkIter + widthB * global_y];
				}

			}else{
				
				shiftInY = (global_y) % LOCALWS;
				
				for(int numWorkIter = 0; numWorkIter < threadCalcUnits;  numWorkIter++){

					locMatrB[local_y][local_x * threadCalcUnits + numWorkIter] 
						= b[global_x * threadCalcUnits + LOCALWS * i * widthB + numWorkIter + widthB * shiftInY];
				}
			}

			barrier(CLK_LOCAL_MEM_FENCE);

			
			float value = 0.0;
			float value1 = 0.0;

			for(int k = 0; k < LOCALWS; k++){

				float common = locMatrA[local_y][k];

				for(int j = 0; j < threadCalcUnits; j++){
					
					values[j] += common * locMatrB[k][local_x * threadCalcUnits + j];
				}

			}

			for(int j = 0; j < threadCalcUnits; j++){

				c[global_x * threadCalcUnits + j + global_y * widthB] += values[j];
				values[j] = 0.0;
			}
			
		}

}

kernel void matrix_vector(global const float* a, global const float* b, global float* c, 
									int widthA, int widthB, int threadCalcUnits){

		int local_x = get_local_id(0);
		int local_y = get_local_id(1);

		int global_x = get_global_id(0);//x координата
		int global_y = get_global_id(1);//y координата


		local float locMatrA[LOCALWS][LOCALWS];
		local float8 locMatrB[LOCALWS][LOCALWS/8];

		float8 value = 0.0;

		for(int i = 0; i < NUM_OF_SUBMATRIX; i++){

			for(int numWorkIter = 0; numWorkIter < threadCalcUnits;  numWorkIter++){

				locMatrA[local_y][local_x * threadCalcUnits + numWorkIter] 
					= a[global_y * widthA + local_x * threadCalcUnits + numWorkIter + i*LOCALWS];
			}

			float8 matrBVector = (float8) (0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f);

			int shiftInY = 0;
			if(global_y + 1 <= LOCALWS){

				matrBVector = vload8(0, &b[global_x * threadCalcUnits + LOCALWS * i * widthB + widthB * global_y]);

				locMatrB[local_y][local_x] = matrBVector;
				
			}else{
			
				shiftInY = (global_y) % LOCALWS;

				matrBVector = vload8(0, &b[global_x * threadCalcUnits + LOCALWS * i * widthB + widthB * shiftInY]);

				locMatrB[local_y][local_x] = matrBVector;

			}


			barrier(CLK_LOCAL_MEM_FENCE);
			

			for(int k = 0; k < LOCALWS; k++){

				value += locMatrA[local_y][k] * locMatrB[k][local_x];
			}

		}
		
		vstore8(value, 0, &c[global_x * threadCalcUnits + global_y * widthB]);

}
